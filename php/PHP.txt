1、处理脚本让浏览器按照指定字符集解析的方法：
在文件顶部加一行代码：
header('Content-type:text/html;charset=utf-8');
这样页面就能正常解析中文了。

2、快捷键：
1、服务管理器的打开方式：
	win徽标 + r   打开运行窗口
 然后再输入services.msc即可





URL中只有名词
get从服务器获取资源(一项或多项)
post在服务器新建一个资源。
put在服务器更新资源（客户端提供改变后的完整资源）。
patch在服务器更新资源（客户端提供改变的属性）。
delete从服务器删除资源。

一，配置环境：
1，win10中80端口被占用？
解决办法：1、打开注册表：regedit
2、找到：HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\services\HTTP
3、在右边找到Start这一项，将其改为0
4、重启系统，System进程不会占用80端口
重启之后，再启动Apache就可以了。

二，流程控制
1，顺序结构：代码一行接着一行的执行；
2，分支结构：
3，循环结构：for,while,do...while,
总结各循环的特点：
在已知循环次数时，使用for循环。
在未知循环次数时，使用while循环。
while循环是先判断，再执行。
do...while循环是执行，再判断。
while循环次数是未知的
do...while循环最少执行一次.

三，关于跳出循环break,continue,return
break:终止循环（跳出整个循环）
continue:跳出本次循环。

四，系统预定义常量
__FILF__:取得当前文件名称
__line__:取得当前行号
__FUNCTTON__:取得当前函数名
__CLASS__:取得类名
__METHOD__:取得方法名
PHP_OS:操作
PHP_VERSION:版本
PHP_INT_SIZE:取得整型长度
PHP_INT_MAX:取得最大整数
 
五：函数
1，函数的作用，为什么要用函数？
1）代码重复性使用
2）模块化编程



六：常用系统函数

1）、输出的函数
echo  没有返回值
print()：类似于echo输出提供的内容，本质是结构（不是函数），也可以不用括号。有返回1。
print_r()：类似于var_dump，但是比var_dump简单，不会输出数据的类型，只会输出值（数组打印比较多。）
var_dump()：输出类型以及内容。
sprintf():进制输出

2）有关时间的函数
date()：
time():获取当前时间对应的时间戳
microtime()：获取微秒级别的时间（比如压力，运行速度等）
strtotime()：按照规定格式的字符串转换成时间戳

3）有关数学的函数
max()：指定参数中最大的值
min()：比较两个数中较小的值
rand()：得到一个随机数，指定区间的随机整数
mt_rand()：与rand一样，只是底层结构不一样，效率比rand高（建议使用）
round()：四合五入
ceil()：向上取整
floor()：向下取整
pow()：求指定数字的指定指数次结果：pow(2,8)==2^8==256
abs()：绝对值
sqrt()：求平方根

4）有关函数的函数
function_exists():判断指定的函数名字是否在内存中存在（帮助用户不去使用一个不存在的函数，让代码安全性更高）。
func_get_arg()：在自定义函数中去获取指定数值对应的参数
func_get_args()：在自定义函数中获取所有的参数（数组）
func_num_args()：获取当前自定义函数的参数数量，但是不将内容中的元素输出


七、字符串长度问题：
1）基本函数strlen()：得到字符串的长度（字节为单位）
2）多字节字符串的长度问题：包含中文的长度
3）多字节字符串扩展模块：mbstring扩展（mb：Multi Bytes）
首先需要开启mstring扩展
Mbstring扩展针对的是一些关于字符统计：strlen只是针对标准交换码ASCII，mtstring会针对不同的字符集

4）转换函数：
1）转换函数：implode(), explode(), str_split()
Implode(连接方式,数组)：将数组中的元素按照某个规则连接成一个字符串
Explode(分割字符,目标字符串)：将字符串按照某个格式进行分割，变成数组
中国|北京|顺义 == array(‘中国’,‘北京’,’顺义’);
Str_split(字符串,字符长度)：按照指定长度拆分字符串得到数组

2）截取函数：trim(), ltrim(), rtrim()
Trim(字符串[,指定字符])：本身默认是用来去除字符串两边的空格（中间不行），但是也可以指定要去除的内容，是按照指定的内容循环去除两边有的内容：直到碰到一个不是目标字符为止
Ltrim()：去除左边的
Rtrim()：去除右边的

3）截取函数：substr(), strstr()
Substr(字符串,起始位置从0开始[,长度])：指定位置开始截取字符串，可以截取指定长度（不指定到最后）
Strstr(字符串,匹配字符)：从指定位置开始，截取到最后（可以用来去文件后缀名）

4）大小转换函数：strtolower(), strtoupper(), ucfirst()
Strtolower：全部小写
Strtoupper：全部大写
Ucfirst：首字母大写

5）查找函数：strpos(), strrpos()
Strpos(字符串，匹配字符)：判断字符在目标字符串中出现的位置（首次）
Strrpos(字符串，匹配字符)：判断字符在目标字符串中最后出现的位置

6）替换函数：str_replace()
Str_replace(匹配目标,替换的内容,字符串本身)：将目标字符串中部分字符串进行替换

7）格式化函数：printf(), sprintf()
Printf/sprintf(输出字符串有占位符,顺序占位内容..)：格式化输出数据

8）其他：str_repeat(), str_shuffle()
Str_repeat()：重复某个字符串N次
Str_shuffle()：随机打乱字符串


八、错误处理

1、错误分类：
1）语法错误：用户书写的代码不符合PHP的语法规范，语法错误无会导致代码在编译过程中通过，所以代码不会执行（parse error）
2) 运行时错误：代码编译通过，但是代码在执行的过程中会出现一些条件不满足导致的错误（runtime error）
3) 逻辑错误：程序员在写代码的时候不够规范，出现了一些逻辑性的错误，导致代码正常执行，但是得不到想要的结果。

2、错误代码：所有看到的错误代码在PHP中都被定义成了系统常量（可以直接使用）

1）系统错误：
E_PARSE：编译错误，代码不会执行
E_ERROR:fatal error,知名错误，会导致代码不能正确继续执行（出错的位置断掉）
E_WARNING：warning,警告错误，不会影响代码执行，但是可能得到意想不到的结果
E_NOTICE：notice,通知错误，不会影响代码执行

2）用户错误（专门给用户使用）：E_USER_ERROR,E_USER_WARNING,E_USER_NOTICE
用户在使用自定义错误触发的时候，会使用到的错误代号（系统不会用到）
3）其他:E_ALL，代表着所有错误（通常在进行错误控制的时候使用比较多），建议在开发过程中（开发环境）使用。

所有以E开头的错误常量（代号），其实都是由一个字节存储，然后每一种错误占据一个对应的位，如果想进行一些错误的控制，可以使用位运算进行操作
排除通知级别notice:E_ALL & ~E_NOTICE
只要警告和通知：E_WARNING | E_NOTICE

error_log配置项：
1、在php.ini中开启日志功能
log_errors = On;
2、指定路径
error_log = '路径自己指定'

八、字符串转义
\'：在单引号字符串中显示单引号
\"：在双引号字符串中显示双引号
\r：代表回车（理论上是回到当前行的首位置）
\n：代表新一行
\t：类似tab键，输出4个空格
\$：在PHP中使用$符号作为变量符号，因此需要特定识别
注意：
单引号和双引号的区别：
1、单引号中只能识别\'，双引号不能识别\'，其余的都没识别。
2、双引号中能够识别解析变量，而单引号中不能识别变量。

双引号中变量识别的规则：
1）、变量本身系统能够与后面的内容区分：应该保证变量的独立性，不用让系统难以区分。
2）、双引号中因为能够识别$符号，所以双引号中可以解析变量，而单引号不可以。

结构化定义字符串变量的规则：
1、结构化定义字符串对应的边界符有条件：
1.1上边界符后面不能跟任何内容（包括空格和注释）；
1.2下边界符必须顶格：就是最左边。
1.3下边界符同样后面只能跟分号，不能跟任何内容。

2、结构化定义字符串的内部（边界符之间）的所有内容都是字符串本身





注意：session.cookie_lifetime，这个过期只是Cookie过期, 可能他还没理解Cookie和Session的区别, Session过期是服务器过期, 而Cookie过期是客户端来保证的, 即使你设置了Cookie过期, 这个只能保证标准浏览器到期的时候, 不会发送这个Cookie, 而如果通过构造请求, 还是可以使用这个Session ID的值



1，gbk中，一个汉字两个字符。UTF-8中，一个汉字三个字符。
2，exit();//输出一个消息并且退出当前脚本（exit()之下所有的语句，包括php,css,js,html代码都停止执行）


入门级：
 可以完整的搭建自己的网站和进行域名解析绑定操作，
 在windows下能完整的配置环境，能看懂dedecms，ecshop，smarty等代码，可以进行模板的修改和常规功能的二次开发。
 可以用thinkphp或者YII进行CURD操作。可以对企业网站数据库进行迁移备份。掌握ajax，cookie，session等基本概念的使用。了解php的语法，数组，字符串，可以写最简单的算法比如简单的随机分组读取，用过100个以上的php函数，同时需要掌握一定div+css html  js jquery的前端知识（这种php程序员大部分在外包或者对企业网站进行维护公司）

 初级：
 可以在Linux下独立的配置LAMP或者LNMP环境（保持简单的运行即可）使用过20个以上的Linux命令，掌握Linux的目录大致结构。可以手写一定的原生mysql和对mysql进行初步的管理。理解了MVC系统的构成，可以完成对该系统的一些简单改写使得更加符合开发要求。理解php库的概念，同时使用过五个以上其他的函数库。可以用php在理解了业务逻辑的情况下，完成小型模块的编写并进行维护，理解api和数据交换概念，可以很快完成对各种开放API同时可以使用svn或者git进行合作协同开发（比如腾讯和微信api）进行组合利用。（很大一部分初创公司招聘的php程序员）

 中级进阶：
 可以看懂LNMP的log日志，使用过40个以上的Linux的命令（组合算新功能命令） 可以完成简单的shell脚本编写，完成部分自动化工作，可以自己独立make安装php的某个需要支持库。 理解性的配置nginx上的server/fastcgi_pass/access_log等选项。可以自己独立make安装php的某个需要支持库
 熟悉各种跟MySQL操作链接的api（mysql/mysqli/PDO)等的不同。能很快的看懂一个mvc结构框架。理解一些数据库的读取效率与基本的设计（可以独立在不考虑效率的情况表现一套简单的业务逻辑，例如签到系统）道基本的InnoDB/MyISAM索引存储结构和不同（聚簇索引，B树）；知道基本的InnoDB事务处理机制了解部分MySQL异常情况的处理方案。同时了解nosql,能使用Redis或者Memcache进行数据的储存。
 理解程序算法结构对程序运行的效率影响，可以用php进行模块开发，同时对自己熟悉的框架进行拓展性改造。
 熟悉基本的HTTP协议（协议代码200/300/400/500，基本的HTTP交互头）（中型公司招聘的php写功能开发的，小公司的主管也常常在该级）
 
 中级:
 能够流畅的使用Shell脚本来完成很多自动化的工作；awk/sed/perl 也操作的不错，能够完成很多文本处理和数据统计等工作；基本能够安装大部分非特殊的Linux程序（包括各种库、包、第三方依赖等等，比如MongoDB/Redis/Sphinx/Luncene/SVN之类的）；了解基本的Linux服务，知道如何查看Linux的性能指标数据，
 了解复杂一些的Nginx配置；包括 多核配置、events、proxy_pass，sendfile/tcp_*配置，知道超时等相关配置和性能影响；知道nginx除了web server，还能够承担代理服务器、反向静态服务器等配置；知道基本的nginx配置调优；知道如何配置权限、编译一个nginx扩展到nginx；知道基本的nginx运行原理（master/worker机制，epoll），知道为什么nginx性能比apache性能好等知识。
 熟悉常规SQL优化（group by/order by/rand优化等）；除了能够搭建MySQL，还能够冷热备份MySQL数据，利用主从配置进行读取优化，知道影响innodb/myisam性能的配置选项（比如key_buffer/query_cache/sort_buffer/innodb_buffer_pool_size/innodb_flush_log_at_trx_commit等）
 PHP上已经对大部分框架掌握了（一般会用过俩种以上做过项目开发），可以写出自己的MVC框架，理解常见的面向对象开发方式（抽象工厂/单例/观察者/命令链/策略/适配器 等模式）由于php层已经到了瓶颈层，会对C/c++进行一定的了解，可以对用C或者c++写一定的简单的程序并进行编译等操作。为了优化性能，可能会用到HHVM等工具
 由于可以对一般的系统进行设计，需要考虑到性能和优化方面，需要Memcached和Redis的异同和应用场景，了解Memcahed的一些基本特性和限制，比如最大的value值，知道PHP跟他们的使用结合；Redis了解基本工作原理和使用，了解常规的数据类型，知道什么场景应用什么类型，了解Redis的事务等等。原理部分，能够大概了解Memcached的内存结构（slab机制），redis就了解常用数据类型底层实现存储结构（SDS/链表/SkipList/HashTable）等等，顺便了解一下Redis的事务、RDB、AOF（大部分公司招聘公司里提到的高级php要求）

 高级进阶：
 可以用c/c++进行写小型规模的程序，基本的C/C++语法熟悉（指针、数组操作、字符串、常规标准API）和数据结构（链表、树、哈希、队列）有一定的熟悉下；会简单的makefile文件编写，能够使用简单的GCC/GDB的程序编译简单调试工作；对基本的网络编程有大概了解。可以使用高级复杂的Linux命令完成工作（watch/tcpdump/starce/ldd/ar等)能够编写比较复杂的shell脚本（超过500行）来协助完成很多包括备份、自动化处理、监控等工作的shell；对awk/sed/perl 等应用已经如火纯青，能够随意操作控制处理文本统计分析各种复杂格式的数据；对Linux内部机制有一些了解，对内核模块加载，启动错误处理等等有个基本的处理；同时对一些其他相关的东西也了解，比如NFS、磁盘管理等等。
 数据库方面可以对大批量数据的导入导出，线上大批量数据的更改表结构或者增删索引字段等等高危操作；除了安装配置，已经能够处理更多复杂的MySQL的问题，比如各种问题的追查，主从同步延迟问题的解决、跨机房同步数据方案、MySQL高可用架构等都有涉及了解；对MySQL应用层面，对MySQL的核心关键技术比较熟悉，比如事务机制（隔离级别、锁等）、对触发器、分区等技术有一定了解和应用；对MySQL性能方面，有包括磁盘优化（SAS迁移到SSD）。
 理解php-fpm工作机制（比如php-fpm在不同配置机器下面开启进程数量计算以及原理），对zend引擎有基本熟悉（vm/gc/stream处理），阅读过基本的PHP内核源码（或者阅读过相关文章），对PHP内部机制的大部分核心数据结构（基础类型/Array/Object）实现有了解，对于核心基础结构（zval/hashtable/gc）有深入学习了解；能够进行基本的PHP扩展开发，了解一些扩展开发的中高级知识（minit/rinit等），熟悉php跟apache/nginx不同的通信交互方式细节（mod_php/fastcgi）。(非常非常厉害的php程序员，圈子太窄了，就知道一俩个)

 高级:
  代码内核部分基本都阅览过（lmnp），熟悉多进程、多线程编程；多进程情况下面了解大部分多进程之间的通信方式，能够灵活选择通信方式（共享内存/信号量/管道等）；多线程编程能够良好的解决锁冲突问题，并且能够进行多线程程序的开发调试工作；同时对网络编程比较熟悉，了解多进程模型/多线程模型/异步网络IO模型的差别和选型，熟悉不同异步网络IO模型的原理和差异（select/poll/epoll/iocp等），并且熟悉常见的异步框架（ACE/ICE/libev/libevent/libuv/Boost.ASIO等）和使用，如果闲暇也可以看看一些国产自己开发的库（比如muduo）；同时能够设计好的高并发程序架构（leader-follow/master-worker等）；了解大部分C/C++后端Server开发中的问题（内存管理、日志打印、高并发、前后端通信协议、服务监控），知道各个后端服务RPC通信问题（struct/http/thirft/protobuf等）；能够更熟络的使用GCC和GDB来开发编译调试程序，在线上程序core掉后能够迅速追查跟踪解决问题。（超越了php的范畴，感觉像独孤求败了）